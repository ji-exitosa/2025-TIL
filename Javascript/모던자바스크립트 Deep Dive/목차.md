
01. 프로그래밍
	1. 프로그래밍이란?
	2. 프로그래밍 언어
	3. 구문과 의미

02. 자바스크립트란?
	1. 자바스크립트의 탄생
	2. 자바스크립트의 표준화
	3. 자바스크립트 성장의 역사
		1. Ajax
		2. jQuery
		3. V8 자바스크립트 엔진
		4. Node.js
		5. SPA 프레임워크
	4. 자바스크립트와 ECMAScript
	5. 자바스크립트의 특징
	6. ES6 브라우저 지원 현황

03. 자바스크립트 개발 환경과 실행 방법
	1. 자바스크립트 실행 환경
	2. 웹 브라우저
		1. 개발자 도구
		2. 콘솔
		3. 브라우저에서 자바스크립트 실행
		4. 디버깅
	3. Node.js
		1. Node.js와 npm 소개
		2. Node.js 설치
		3. Node.js REPL
	4. 비주얼 스튜디오 코드
		1. 비주얼 스튜디오 코드 설치
		2. 내장 터미널
		3. Code Runner 확장 플러그인
		4. Live Server 확장 플러그인

04. 변수
	1. 변수란 무엇인가? 왜 필요한가?
	2. 식별자
	3. 변수 선언
	4. 변수 선언의 실행 시점과 변수 호이스팅
	5. 값의 할당
	6. 값의 재할당
	7. 식별자 네이밍 규치

05. 표현식과 문
	1. 값
	2. 리터럴
	3. 표현식
	4. 문
	5. 세미콜론과 세미콜론 자동 삽입 기능
	6. 표현식인 문과 표현식이 아닌 문

06. 데이터 타입
	1. 숫자 타입
	2. 문자열 타입
	3. 템플릿 리터럴
		1. 멀티라인 문자열
		2. 표현식 삽입
	4. 불리언 타입
	5. undefined 타입
	6. null 타입
	7. 심벌 타입
	8. 객체 타입
	9. 데이터 타입의 필요성
		1. 데이터 타입에 의한 메모리 공간의 확보와 참조
		2. 데이터 타입에 의한 값의 해석
	10. 동적 타이핑
		1. 동적 타입 언어와 정적 타입 언어
		2. 동적 타입 언어와 변수

07. 연산자
	1. 산술 연산자
		1. 이항 산술 연산자
		2. 단항 산술 연산자
		3. 문자열 연결 연산자
	2. 할당 연산자
	3. 비교 연산자
		1. 동등/일치 비교 연산자
		2. 대소 관계 비교 연산자
	4. 삼항 조건 연산자
	5. 논리 연산자
	6. 쉼표 연산자
	7. 그룹 연산자
	8. typeof 연산자
	9. 지수 연산자
	10. 그 외의 연산자
	11. 연산자의 부수 효과
	12. 연산자 우선순위
	13. 연산자 결합 순위

08. 제어문
	1. 블록문
	2. 조건문
		1. if ... else 문
		2. switch 문
	3. 반복문
		1. for 문
		2. while 문
		3. do ... while 문
	4. break 문
	5. continue 문

09. 타입 변환과 단축 평가
	1. 타입 변환이란
	2. 암묵적 타입 변환
		1. 문자열 타입으로 변환
		2. 숫자 타입으로 변환
		3. 불리언 타입으로 변환
	3. 명시적 타입 변환
		1. 문자열 타입으로 변환
		2. 숫자 타입으로 변환
		3. 불리언 타입으로 변환
	4. 단축 평가
		1. 논리 연산자를 사용한 단축 평가
		2. 옵셔널 체이닝 연산자
		3. null 병합 연산자

10. 객체 리터럴
	1. 객체란?
	2. 객체 리터럴에 의한 객체 생성
	3. 프로퍼티
	4. 메서드
	5. 프로퍼티 접근
	6. 프로퍼티 값 갱신
	7. 프로퍼티 동적 생성
	8. 프로퍼티 삭제
	9. ES6에서 추가된 객체 리터럴의 확장 기능
		1. 프로퍼티 축약 표현
		2. 계산된 프로퍼티 이름
		3. 메서드 축약 표현

11. 원시 값과 객체의 비교
	1. 원시 값
		1. 변경 불가능한 값
		2. 문자열과 불변성
		3. 값에 의한 전달
	2. 객체
		1. 변경 가능한 값
		2. 참조에 의한 전달

12. 함수
	1. 함수란?
	2. 함수를 사용하는 이유
	3. 함수 리터럴
	4. 함수 정의
		1. 함수 선언문
		2. 함수 표현식
		3. 함수 생성 시점과 함수 호이스팅
		4. Function 생성자 함수
		5. 화살표 함수
	5. 함수 호출
		1. 매개변서와 인수
		2. 인수 확인
		3. 매개변수의 최대 개수
		4. 반환문
	6. 참조에 의한 전달과 외부 상태의 변경
	7. 다양한 함수의 형태
		1. 즉시 실행 함수
		2. 재귀 함수
		3. 중첩 함수
		4. 콜백 함수
		5. 순수 함수와 비순수 함수

13. 스코프
	1. 스코프란?
	2. 스코프의 종류
		1. 전역과 전역 스코프
		2. 지역과 지역 스코프
	3. 스코프 체인
		1. 스코프 체인에 의한 변수 검색
		2. 스코프 체인에 의한 함수 검색
		3. 함수 레벨 스코프
		4. 렉시컬 스코프

14. 전역 변수의 문제점
	1. 변수의 생명 주기
		1. 지역 변수의 생명 주기
		2. 전역 변수의 생명 주기
	2. 전역 변수의 문제점
	3. 전역 변수의 사용을 억제하는 방법
		1. 즉시 실행 함수
		2. 네임스페이스 객체ㅔ
		3. 모듈 패턴
		4. ES6 모듈

15.  let, const 키워드와 블록 레벨 스코프
	1. var 키워드로 선언한 변수의 문제점
		1. 변수 중복 선언 허용
		2. 함수 레벨 스코프
		3. 변수 호이스팅
	2. let 키워드
		1. 변수 중복 선언 금지
		2. 블록 레벨 스코프
		3. 변수 호이스팅
		4. 전역 객체와 let
	3. const 키워드
		1. 선언과 초기화
		2. 재할당 금지
		3. 상수
		4. const 키워드와 객체
	4. var vs. let vs. const

16. 프로퍼티 어트리뷰트
	1. 내부 슬롯과 내부 메서드
	2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
	3. 데이터 프로퍼티와 접근자 프로퍼티
		1. 데이터 프로퍼티
		2. 접근자 프로퍼티
	4. 프로퍼티 정의
	5. 객체 변경 방지
		1. 객체 확장 금지
		2. 객체 밀봉
		3. 객체 동결
		4. 불변 객체

17. 생성자 함수에 의한 객체 생성
	1. Object 생성자 함수
	2. 생성자 함수
		1. 객체 리터럴에 의한 객체 생성 방식의 문제점
		2. 생성자 함수에 의한 객체 생성 방식의 장점
		3. 생성자 함수의 인스턴스 생성 과정
		4. 내부 메서드 'Call'과 'Construct'
		5. construct와 non-construct의 구분
		6. new 연산자
		7. new.target

18. 함수와 일급 객체
	1. 일급 객체
	2. 함수 객체의 프로퍼티
		1. arguments 프로퍼티
		2. caller 프로퍼티
		3. length 프로퍼티
		4. name 프로퍼티
		5. \_\_proto__접근자 프로퍼티
		6. prototype 프로퍼티

19. 프로토타입
	1. 객체지향 프로그래밍
	2. 상속과 프로토타입
	3. 프로토타입 객체
		1. \_\_proto__ 접근자 프로퍼티
		2. 함수 객체의 prototype 프로퍼티
		3. 프로토타입의 constructor 프로퍼티와 생성자 함수
	4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
	5. 프로토타입의 생성 시점
		1. 사용자 정의 생성자 함수와 프로토타입 생성 시점
		2. 빌트인 생성자 함수와 프로토타입 생성 시점
	6. 객체 생성 방식과 프로토타입의 결정
		1. 객체 리터럴에 의해 생성된 객체의 프로토타입
		2. Object 생성자 함수에 의해 생성된 객체의 프로토타입
		3. 생성자 함수에 의해 생성된 객체의 프로토타입
	7. 프로토타입 체인
	8. 오버라이딩과 프로퍼티 섀도잉
	9. 프로토타입의 교체
		1. 생성자 함수에 의한 프로토타입의 교체
		2. 인스턴스에 의한 프로토타입의 교체
	10. instanceof 연산자
	11. 직접 상속
		1. Object.create에 의한 직접 상속
		2. 객체 리터럴 내부에서 \_\_proto__에 의한 직접 상속
	12. 정적 프로퍼티/메서드
	13. 프로퍼티 존재 확인
		1. in 연산자
		2. Object.prototype.hasOwnProperty 메서드
	14. 프로퍼티 열거
		1. for ... in 문
		2. Object\.keys/values/entires 메서드

20. strict mode
	1. strict mode란?
	2. strict mode의 적용
	3. 전역에 strict mode를 적용하는 것은 피하자
	4. 함수 단위로 strict mode를 적용하는 것도 피하자
	5. strict mode가 발생시키는 에러
		1. 암묵적 전역
		2. 변수, 함수, 매개변수의 삭제
		3. 매개변수 이름의 중복
		4. with 문의 사용
	6. strict mode 적용에 의한 변화
		1. 일반 함수의 this
		2. arguments 객체

21. 빌트인 객체
	1. 자바스크립트의 객체의 분류
	2. 표준 빌트인 객체
	3. 원시값과 래퍼 객체
	4. 전역 객체
		1. 빌트인 전역 프로퍼티
		2. 빌트인 전역 함수
		3. 암묵적 전역

22. this
	1. this 키워드
	2. 함수 호출 방식과 this 바인딩
		1. 일반 함수 호출
		2. 메서드 호출
		3. 생성자 함수 호출
		4. Function\.prototype\.apply/call/bind 메서드에 의한 간접 호출

23. 실행 컨텍스트
	1. 소스코드의 타입
	2. 소스코드의 평가와 실행
	3. 실행 컨텍스트의 역할
	4. 실행 컨텍스트 스택
	5. 렉시컬 환경
	6. 실행 컨텍스트의 생성과 식별자 검색 과정
		1. 전역 객체 생성
		2. 전역 코드 평가
		3. 전역 코드 실행
		4. foo 함수 코드 평가
		5. foo 함수 코드 실행
		6. bar 함수 코드 평가
		7. bar 함수 코드 실행
		8. bar 함수 코드 실행 종료
		9. foo 함수 코드 실행 종료
		10. 전역 코드 실행 종료
	7. 실행 컨텍스트와 블록 레벨 스코프

24. 클로저
	1. 렉시컬 스코프
	2. 함수 객체의 내부 슬롯 'Environment'
	3. 클로저와 렉시컬 환경
	4. 클로저의 확용
	5. 캡슐화와 정보 은닉
	6. 자주 발생하는 실수

25. 클래스
	1. 클래스는 프로토타입의 문법접 설탕인가?
	2. 클래스의 정의
	3. 클래스 호이스팅
	4. 인스턴스 생성
	5. 메서드
		1. constructor
		2. 프로토타입 메서드
		3. 정적 메서드
		4. 정적 메서드와 프로토타입 메서드의 차이
		5. 클래스에서 정의한 메서드의 특징
	6. 